/*
 * Copyright (c) 2008-2014 Maxifier Ltd. All Rights Reserved.
 */
package com.maxifier.mongo;

import com.google.gson.stream.JsonWriter;
import org.bson.io.OutputBuffer;

import javax.annotation.Nullable;
import java.io.IOException;

import static com.maxifier.mongo.GsonAdapters.*;

/**
 * Gson specific writer that adapts JSON stream to a binary BSON stream.
 * <p>Works as a wrapper for {@link BsonWriter} which converts special JSON sequences
 * to internal BSON types. Special sequences are generated by
 * {@code TypeAdapter}s declared in {@link GsonAdapters}.</p>
 * <p>Use {@link #reset(OutputBuffer)} to reuse writer instance.</p>
 *
 * @see BsonWriter
 * @see GsonAdapters
 * @author Konstantin Lyamshin (2014-12-11 15:34)
 */
public class GsonWriter extends JsonWriter {
    private final BsonWriter bson;
    private final GsonBuffer.JsonBufferedWriter writer;
    private int bufferDepth;

    public GsonWriter() {
        super(GsonBuffer.NULL_WRITER);
        this.bson = new BsonWriter();
        this.writer = new GsonBuffer().writer();
    }

    public void reset(@Nullable OutputBuffer out) {
        bson.reset(out);
        writer.buffer().clear();
        bufferDepth = 0;
    }

    public BsonWriter getBsonWriter() {
        return bson;
    }

    // ---- Troubleshooting --------------------------------------------------------------------------------------------

    public String getPath() {
        return bson.getPath();
    }

    @Override
    public String toString() {
        return String.format("GsonWriter{%s(%s)}", getPath(), writer);
    }

    // ---- Buffering logic --------------------------------------------------------------------------------------------

    @Override
    public JsonWriter beginObject() {
        writer.beginObject(); // Start buffering
        bufferDepth++;
        return this;
    }

    @Override
    public JsonWriter endObject() {
        if (!writer.isEmpty()) {
            writer.endObject();
            if (--bufferDepth == 0) {
                writeSequence(); // Stop buffering
            }
        } else {
            bson.endObject();
        }
        return this;
    }

    @Override
    public JsonWriter name(String name) {
        if (!writer.isEmpty()) {
            if (!name.startsWith("$") && bufferDepth == 1) {
                writeDefered(); // System sequence not found, stop buffering
                bson.name(name); // Relay name
            } else {
                writer.name(name); // Continue buffering
            }
        } else {
            bson.name(name);
        }
        return this;
    }

    /**
     * Write system sequence to BsonWriter.
     */
    private void writeSequence() {
        GsonBuffer.JsonBufferedReader in = writer.buffer().reader();
        String field = in.peekObjectField();
        if (field == null) { // empty object
            writeDefered();
            return;
        }
        try {
            if (field.equals(F_LONG)) {
                bson.longValue(LONG_ADAPTER.read(in));
            } else if (field.equals(F_DATE)) {
                bson.dateValue(DATE_ADAPTER.read(in));
            } else if (field.equals(F_OBJECTID)) {
                bson.objectIdValue(OBJECTID_ADAPTER.read(in));
            } else if (field.equals(F_UUID)) {
                bson.uuidValue(UUID_ADAPTER.read(in));
            } else if (field.equals(F_NULLABLE)) {
                GsonNullable<?> value = NULLABLE_DUMMY_ADAPTER.read(in);
                assert !value.isPresent(): "Null value should be read";
                bson.nullValue();
            } else if (field.equals(F_BINARY)) {
                bson.binaryValue(BINARY_ADAPTER.read(in));
            } else if (field.equals(F_REGEX)) {
                bson.regexValue(REGEX_ADAPTER.read(in));
            } else if (field.equals(F_TIMESTAMP)) {
                bson.timestampValue(TIMESTAMP_ADAPTER.read(in));
            } else if (field.equals(F_CODE)) {
                bson.codeValue(CODE_ADAPTER.read(in));
            } else if (field.equals(F_MINKEY)) {
                MINKEY_ADAPTER.read(in);
                bson.minkeyValue();
            } else if (field.equals(F_MAXKEY)) {
                MAXKEY_ADAPTER.read(in);
                bson.maxkeyValue();
            } else {
                throw new IllegalArgumentException("Invalid system sequence '" + field + "' at " + toString());
            }
            bufferDepth = 0;
            assert in.isEmpty(): "GsonBuffer wasn't fully read";
        } catch (IOException e) {
            throw new IllegalStateException("Hmm IOException is impossible, are you kidding?", e);
        }
    }

    /**
     * Write buffered stream to BsonWriter.
     */
    private void writeDefered() {
        GsonBuffer.JsonBufferedReader reader = writer.buffer().reader();
        while (true) {
            switch (reader.peek()) {
                case BEGIN_OBJECT:
                    reader.beginObject();
                    bson.beginObject();
                    break;

                case END_OBJECT:
                    reader.endObject();
                    bson.endObject();
                    break;

                case BEGIN_ARRAY:
                    reader.beginArray();
                    bson.beginArray();
                    break;

                case END_ARRAY:
                    reader.endArray();
                    bson.endArray();
                    break;

                case NAME:
                    bson.name(reader.nextName());
                    break;

                case NULL:
                    reader.nextNull();
                    if (bson.isArray()) {
                        bson.nullValue();
                    } else {
                        bson.dropValue(); // Skip null fields
                    }
                    break;

                case STRING:
                    bson.stringValue(reader.nextString());
                    break;

                case NUMBER:
                    bson.numberValue(reader.nextNumber());
                    break;

                case BOOLEAN:
                    bson.booleanValue(reader.nextBoolean());
                    break;

                case END_DOCUMENT:
                    bufferDepth = 0;
                    return; // Finished

                default:
                    bufferDepth = 0;
                    throw new IllegalStateException("Unexpected token found: " + reader.peek());
            }
        }
    }

    // ---- Plain delegation -------------------------------------------------------------------------------------------

    @Override
    public JsonWriter beginArray() {
        if (!writer.isEmpty()) {
            writer.beginArray();
        } else {
            bson.beginArray();
        }
        return this;
    }

    @Override
    public JsonWriter endArray() {
        if (!writer.isEmpty()) {
            writer.endArray();
        } else {
            bson.endArray();
        }
        return this;
    }

    @Override
    public JsonWriter nullValue() {
        if (!writer.isEmpty()) {
            writer.nullValue();
        } else if (bson.isArray()) {
            bson.nullValue();
        } else {
            bson.dropValue(); // Skip null fields
        }
        return this;
    }

    @Override
    public JsonWriter value(String value) {
        if (value == null) {
            return nullValue();
        }
        if (!writer.isEmpty()) {
            writer.value(value);
        } else {
            bson.stringValue(value);
        }
        return this;
    }

    @Override
    public JsonWriter value(boolean value) {
        if (!writer.isEmpty()) {
            writer.value(value);
        } else {
            bson.booleanValue(value);
        }
        return this;
    }

    @Override
    public JsonWriter value(double value) {
        if (!writer.isEmpty()) {
            writer.value(value);
        } else {
            bson.doubleValue(value);
        }
        return this;
    }

    @Override
    public JsonWriter value(long value) {
        boolean useInt = (int) value == value; // detect smallest possible type
        if (!writer.isEmpty()) {
            writer.value(useInt? Integer.valueOf((int) value): Long.valueOf(value));
        } else {
            if (useInt) {
                bson.intValue((int) value);
            } else {
                bson.longValue(value);
            }
        }
        return this;
    }

    @Override
    public JsonWriter value(Number n) {
        if (n == null) {
            return nullValue();
        }
        if (!writer.isEmpty()) {
            writer.value(n);
        } else {
            bson.numberValue(n);
        }
        return this;
    }

    @Override
    public void flush() throws IOException {
        bson.flush();
    }

    @Override
    public void close() throws IOException {
        bson.close();
        writer.buffer().clear();
    }
}
